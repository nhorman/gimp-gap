/* gap_enc_ffmpeg_gui.c
 * 2003.01.07 hof (Wolfgang Hofer)
 *
 * GAP ... Gimp Animation Plugins
 *
 * This Module contains FFMPEG specific Video Encoder GUI Procedures
 */
/* The GIMP -- an image manipulation program
 * Copyright (C) 1995 Spencer Kimball and Peter Mattis
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* revision history:
 * version 2.1.0a;  2004/11/05   hof: replaced deprecated option menu by gimp_int_combo_box
 *                                    reorganized the GUI code. 
 *                                    (the origial code-monster was generated by an old version of glade
 *                                     and was harder to read by humans)
 * version 2.1.0a;  2004.06.05   hof: update params from ffmpeg 0.4.6 to 0.4.8
 * version 2.1.0a;  2004.05.12   hof: integration into gimp-gap project
 * version 1.2.2c;  2003.05.29   hof: dont_recode_flag
 * version 1.2.2c;  2003.01.07   hof: created
 */

#include <config.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <string.h>

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>



#include "gap_libgapvidutil.h"
#include "gap-intl.h"

#include "gap_libgapvidutil.h"
#include "gap_libgimpgap.h"

#include "gap_enc_ffmpeg_main.h"
#include "gap_enc_ffmpeg_gui.h"
#include "gap_enc_ffmpeg_callbacks.h"

/* Includes for encoder specific extra LIBS */
#include "avformat.h"
#include "avcodec.h"

typedef struct
{
  char *name;
  gint  menu_idx;
  void *next;
} t_string_combo_elem;

static void     p_replace_combo_file_format(GapGveFFMpegGlobalParams *gpp);
static void     p_replace_combo_vid_codec(GapGveFFMpegGlobalParams *gpp);
static void     p_replace_combo_aud_codec(GapGveFFMpegGlobalParams *gpp);
static void     p_init_spinbuttons(GapGveFFMpegGlobalParams *gpp);
static void     p_init_vid_checkbuttons(GapGveFFMpegGlobalParams *gpp);
static void     p_init_entry_widgets(GapGveFFMpegGlobalParams *gpp);
static char*    p_init_combo_actual_nameidx(GapGveFFMpegGlobalParams *gpp, GtkWidget *wgt, t_string_combo_elem *list, char *name);
static gint     p_init_gint_combo_actual_idx(GapGveFFMpegGlobalParams *gpp, GtkWidget *widget, gint *gtab_ptr, gint val, gint maxidx);
static gint     p_init_gdouble_combo_actual_idx(GapGveFFMpegGlobalParams *gpp, GtkWidget *widget, gdouble *gtab_ptr, gdouble val, gint maxidx);



GtkWidget*      p_create_basic_options_frame (GapGveFFMpegGlobalParams *gpp);
GtkWidget*      p_create_expert_algortihms_frame (GapGveFFMpegGlobalParams *gpp);
GtkWidget*      p_create_expert_options_frame (GapGveFFMpegGlobalParams *gpp);
GtkWidget*      p_create_2pass_options_frame (GapGveFFMpegGlobalParams *gpp);
GtkWidget*      p_create_file_comment_frame (GapGveFFMpegGlobalParams *gpp);



static gint     gtab_motion_est[GAP_GVE_FFMPEG_MOTION_ESTIMATION_MAX_ELEMENTS] =  { 1, 2, 3, 4, 5, 6 };
static gint     gtab_dct_algo[GAP_GVE_FFMPEG_DCT_ALGO_MAX_ELEMENTS] =  { 0, 1, 2, 3, 4, 5 };
static gint     gtab_idct_algo[GAP_GVE_FFMPEG_IDCT_ALGO_MAX_ELEMENTS] =  { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
static gint     gtab_mb_decision[GAP_GVE_FFMPEG_MB_DECISION_MAX_ELEMENTS] =  { FF_MB_DECISION_SIMPLE, FF_MB_DECISION_BITS, FF_MB_DECISION_RD };
static gint     gtab_audio_krate[GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_MAX_ELEMENTS] = { 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320 };
static gdouble  gtab_aspect[GAP_GVE_FFMPEG_ASPECT_MAX_ELEMENTS] =  { 0.0, 1.5, 1.333333333, 1.777777778 };


/* lists of all available fileformats and codecs
 * (lists are built at runtime by ffmpeg specific query)
 */
t_string_combo_elem  *glist_vid_codec = NULL;
t_string_combo_elem  *glist_aud_codec = NULL;
t_string_combo_elem  *glist_fileformat = NULL;



/* --------------------------------
 * p_replace_combo_file_format
 * --------------------------------
 * replace the fileformat combo by dynamic menu
 * (we get the format names from the FFMPEG Lib)
 */
 
static void
p_replace_combo_file_format(GapGveFFMpegGlobalParams *gpp)
{
  gint  l_active_idx;
  gint  l_idx;
  AVOutputFormat *ofmt;
  t_string_combo_elem  *elem_fileformat;


  if(gap_debug) printf("p_replace_combo_file_format: START\n");

  glist_fileformat = NULL;


  l_idx = 0;
  l_active_idx = 0;

  for(ofmt = first_oformat; ofmt != NULL; ofmt = ofmt->next)
  {
     char *menu_name;
     char *object_data;

     object_data = (char*)ofmt->name;

     menu_name = g_strdup_printf("[%s] %s", object_data, ofmt->long_name);

     if(gap_debug)
     {
        printf("p_replace_combo_file_format: val[%d]: %s\n", (int)l_idx, menu_name);

        printf("MIME_TYPE: %s\n", ofmt->mime_type);
        printf("EXTENSIONS: %s\n", ofmt->extensions);
        printf("Default VID_CODEC ID: %d\n", ofmt->video_codec);
        printf("Default AUD_CODEC ID: %d\n", ofmt->audio_codec);
        printf("flags: %d\n", (int)ofmt->flags );
     }

     /* Filter filefromats (not interested in audio and single image fileformats, pipe ...)
      * - mime_type must be != NULL and should start with "video"
      * - format must support video codec  (codec_id != 0)
      * - formats that support both video_codec and audio_code are accepted
      *   (even if the mime type is not "video")
      */
     if((ofmt->mime_type != NULL) && (ofmt->video_codec != 0))
     {
       if((strncmp(ofmt->mime_type, "video", 5) == 0) || (ofmt->audio_codec != 0))
       {
         elem_fileformat = (t_string_combo_elem *) g_malloc0(sizeof(t_string_combo_elem));
         elem_fileformat->menu_idx = l_idx;
         elem_fileformat->name     = g_strdup(object_data);
         elem_fileformat->next     = glist_fileformat;
         glist_fileformat = elem_fileformat;

         gimp_int_combo_box_append (GIMP_INT_COMBO_BOX (gpp->ff_fileformat_combo),
                                 GIMP_INT_STORE_VALUE, l_idx,
                                 GIMP_INT_STORE_LABEL, menu_name,
                                 -1);

         if(strcmp(object_data, gpp->evl.format_name) == 0)
         {
             l_active_idx = l_idx;
         }
         l_idx++;
       }
     }
  }

  g_object_set_data (G_OBJECT (gpp->ff_fileformat_combo)
	            , GAP_ENC_FFGUI_COMBO_STRLIST
		    , (gpointer)glist_fileformat
		    );

  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (gpp->ff_fileformat_combo)
                             , l_active_idx,
                              G_CALLBACK (on_ff_fileformat_combo),
                              gpp);

  /* gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (gpp->ff_fileformat_combo)
   *                              , l_active_idx);
   */
}  /* end p_replace_combo_file_format */


/* --------------------------------
 * p_replace_combo_vid_codec
 * --------------------------------
 * replace the vid_codec combo by dynamic menu
 * (we get the video codecs from the FFMPEG Lib)
 */
static void
p_replace_combo_vid_codec(GapGveFFMpegGlobalParams *gpp)
{
  gint  l_active_idx;
  gint  l_idx;
  AVCodec *avcodec;
  t_string_combo_elem  *elem_vid_codec;


  if(gap_debug) printf("p_replace_combo_vid_codec: START\n");

  glist_vid_codec = NULL;

  l_idx = 0;
  l_active_idx = 0;

  for(avcodec = first_avcodec; avcodec != NULL; avcodec = avcodec->next)
  {
     char *menu_name;
     char *object_data;
     if ((avcodec->encode) && (avcodec->type == CODEC_TYPE_VIDEO))
     {
       object_data = (char *)avcodec->name;

       menu_name = g_strdup(object_data);

       if(gap_debug)
       {
          printf("p_replace_combo_vid_codec: val[%d]: %s\n"
	         , (int)l_idx
		 , menu_name
		 );
       }
       elem_vid_codec = (t_string_combo_elem *) g_malloc0(sizeof(t_string_combo_elem));
       elem_vid_codec->menu_idx = l_idx;
       elem_vid_codec->name     = g_strdup(object_data);
       elem_vid_codec->next     = glist_vid_codec;
       glist_vid_codec = elem_vid_codec;

       gimp_int_combo_box_append (GIMP_INT_COMBO_BOX (gpp->ff_vid_codec_combo),
                                 GIMP_INT_STORE_VALUE, l_idx,
                                 GIMP_INT_STORE_LABEL, menu_name,
                                 -1);

       if(strcmp(object_data, gpp->evl.vcodec_name) == 0)
       {
           l_active_idx = l_idx;
       }
       l_idx++;
     }
  }

  g_object_set_data (G_OBJECT (gpp->ff_vid_codec_combo)
	            , GAP_ENC_FFGUI_COMBO_STRLIST
		    , (gpointer)glist_vid_codec
		    );
  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (gpp->ff_vid_codec_combo)
                             , l_active_idx,
                              G_CALLBACK (on_ff_vid_codec_combo),
                              gpp);

  /* gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (gpp->ff_vid_codec_combo)
   *                              , l_active_idx);
   */

}  /* end p_replace_combo_vid_codec */


/* --------------------------------
 * p_replace_combo_aud_codec
 * --------------------------------
 * replace the aud_codec combo by dynamic menu
 * (we get the audio codecs from the FFMPEG Lib)
 */
static void
p_replace_combo_aud_codec(GapGveFFMpegGlobalParams *gpp)
{
  gint  l_active_idx;
  gint  l_idx;
  AVCodec *avcodec;
  t_string_combo_elem  *elem_aud_codec;


  if(gap_debug) printf("p_replace_combo_aud_codec: START\n");

  glist_aud_codec = NULL;

  l_idx = 0;
  l_active_idx = 0;

  for(avcodec = first_avcodec; avcodec != NULL; avcodec = avcodec->next)
  {
     char *menu_name;
     char *object_data;
     if ((avcodec->encode) && (avcodec->type == CODEC_TYPE_AUDIO))
     {
       object_data = (char *)avcodec->name;

       menu_name = g_strdup(object_data);

       if(gap_debug)
       {
          printf("p_replace_combo_aud_codec: val[%d]: %s\n"
	        , (int)l_idx
		, menu_name
		);
       }
       elem_aud_codec = (t_string_combo_elem *) g_malloc0(sizeof(t_string_combo_elem));
       elem_aud_codec->menu_idx = l_idx;
       elem_aud_codec->name     = g_strdup(object_data);
       elem_aud_codec->next     = glist_aud_codec;
       glist_aud_codec = elem_aud_codec;

       gimp_int_combo_box_append (GIMP_INT_COMBO_BOX (gpp->ff_aud_codec_combo),
                                 GIMP_INT_STORE_VALUE, l_idx,
                                 GIMP_INT_STORE_LABEL, menu_name,
                                 -1);

       if(strcmp(object_data, gpp->evl.acodec_name) == 0)
       {
           l_active_idx = l_idx;
       }
       l_idx++;
     }
  }

  g_object_set_data (G_OBJECT (gpp->ff_aud_codec_combo)
	            , GAP_ENC_FFGUI_COMBO_STRLIST
		    , (gpointer)glist_aud_codec
		    );
  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (gpp->ff_aud_codec_combo)
                             , l_active_idx,
                              G_CALLBACK (on_ff_aud_codec_combo),
                              gpp);

  /* gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (gpp->ff_aud_codec_combo)
   *                              , l_active_idx);
   */

}  /* end p_replace_combo_aud_codec */



/* ----------------------------
 * gap_enc_ffgui_set_default_codecs
 * ----------------------------
 * - findout the default CODECS and Extensions for the current selected fileformat
 *   and show this informations in the info label widget.
 * - opütional (if set_codec_menus == TRUE)
 *   set both VIDEO_CODEC and AUDIO_CODEC combo to these default CODECS
 */
void
gap_enc_ffgui_set_default_codecs(GapGveFFMpegGlobalParams *gpp, gboolean set_codec_menus)
{
   AVOutputFormat *ofmt;
   AVCodec *aud_codec;
   AVCodec *vid_codec;
   char *name;
   char *l_ext_one;
   guint l_ii;

   if(gpp == NULL) return;
   if(gpp->shell_window == NULL) return;

   ofmt = guess_format(gpp->evl.format_name, NULL, NULL);

   if(ofmt)
   {
     char *info_msg;
     char *default_vid_codec;
     char *default_aud_codec;

     /* find default CODECS for the fileformat */
     vid_codec = avcodec_find_encoder(ofmt->video_codec);
     aud_codec = avcodec_find_encoder(ofmt->audio_codec);

     if(vid_codec)
     {
       default_vid_codec = g_strdup(vid_codec->name);
       if(set_codec_menus)
       {
         /* set combo */
         name = p_init_combo_actual_nameidx(gpp, gpp->ff_vid_codec_combo, glist_vid_codec, default_vid_codec);

         if (name)
         {
            g_snprintf(gpp->evl.vcodec_name, sizeof(gpp->evl.vcodec_name), "%s", name);
         }
       }
     }
     else
     {
       default_vid_codec = g_strdup(_("NOT SUPPORTED"));
     }
     if(aud_codec)
     {
       default_aud_codec = g_strdup(aud_codec->name);
       if(set_codec_menus)
       {
         /* set combo */
         name = p_init_combo_actual_nameidx(gpp, gpp->ff_aud_codec_combo, glist_aud_codec, default_aud_codec);
         if (name)
         {
            g_snprintf(gpp->evl.acodec_name, sizeof(gpp->evl.acodec_name), "%s", name);
         }
       }
     }
     else
     {
       default_aud_codec = g_strdup(_("NOT SUPPORTED"));
     }

     info_msg = g_strdup_printf(_("Selected Fileformat : [%s] %s\n"
                                  "Recommanded Video CODEC : %s\n"
                                  "Recommanded Audio CODEC : %s\n"
                                  "Extension(s): %s"
                                 )
                               , ofmt->name
                               , ofmt->long_name
                               , default_vid_codec
                               , default_aud_codec
                               , ofmt->extensions
                               );
     /* store the current video extension
      * ofmt->extensions may contain more than 1 extension (comma seperated)
      * but we always use only the 1.st one.
      */
     if(ofmt->extensions)
     {
       l_ext_one = g_strdup_printf(".%s", ofmt->extensions);
     }
     else
     {
       /* mpeg1 system format (VCD) has no extensions (is that a bug in the lib ?)
        * assume .mpg for videoformats without extensions as workaround
        */
       l_ext_one = g_strdup(".mpg");
     }

     for(l_ii=0; l_ii < sizeof(gpp->evl.current_vid_extension)-2; l_ii++)
     {
          if ((l_ext_one[l_ii] == '\0')
          ||  (l_ext_one[l_ii] == ';')
          ||  (l_ext_one[l_ii] == ',')
          ||  (l_ext_one[l_ii] == ':'))
          {
            gpp->evl.current_vid_extension[l_ii] = '\0';
            break;
          }
          gpp->evl.current_vid_extension[l_ii] = l_ext_one[l_ii];
     }
     g_free(l_ext_one);

     /* update info label with default codec names and extensions
      * for the selected fileformat
      */
     gtk_label_set_text(GTK_LABEL(gpp->ff_basic_info_label), info_msg);

     g_free(info_msg);
     g_free(default_vid_codec);
     g_free(default_aud_codec);
   }

}  /* end gap_enc_ffgui_set_default_codecs */


/* --------------------------------
 * gap_get_combo_string_by_idx
 * --------------------------------
 */
const char *
gap_get_combo_string_by_idx(gpointer string_combo_elem_list, gint idx)
{
  t_string_combo_elem  *list;
  t_string_combo_elem  *elem;
  
  list = (t_string_combo_elem *)string_combo_elem_list;
  
  if(gap_debug)
  {
    if(string_combo_elem_list == (gpointer)glist_vid_codec)
    {
      printf("gap_get_combo_string_by_idx: glist_vid_codec  ptr:%d\n"
            ,(int)string_combo_elem_list
	    );
    }
    if(string_combo_elem_list == (gpointer)glist_aud_codec)
    {
      printf("gap_get_combo_string_by_idx: glist_aud_codec  ptr:%d\n"
            ,(int)string_combo_elem_list
	    );
    }
    if(string_combo_elem_list == (gpointer)glist_fileformat)
    {
      printf("gap_get_combo_string_by_idx: glist_fileformat  ptr:%d\n"
            ,(int)string_combo_elem_list
	    );
    }
  }
  
  for(elem = list; elem != NULL; elem = (t_string_combo_elem  *)elem->next)
  {
    if (idx == elem->menu_idx)
    {
      return (elem->name);
    }
  }


  printf("gap_get_combo_string_by_idx: ** ERROR no list elem found at index:%d\n"
        ,(int)idx
        );
  return (NULL);
  
}  /* end gap_get_combo_string_by_idx */


/* --------------------------------
 * p_init_combo_actual_nameidx
 * --------------------------------
 */
static char *
p_init_combo_actual_nameidx(GapGveFFMpegGlobalParams *gpp, GtkWidget *widget, t_string_combo_elem *list, char *name)
{
  t_string_combo_elem  *elem;


  if(gap_debug) printf("p_init_combo_actual_nameidx START search: %s\n", name);
  for(elem = list; elem != NULL; elem = (t_string_combo_elem  *)elem->next)
  {
    if(strcmp(name, elem->name) == 0)
    {
      gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (widget), elem->menu_idx);
      if(gap_debug) printf("p_init_combo_actual_nameidx START found: %s\n", name);
      return(elem->name);
    }
  }
  return (NULL);
}  /* end p_init_combo_actual_nameidx */

/* ---------------------------------
 * p_init_gint_combo_actual_idx
 * ---------------------------------
 */
static gint
p_init_gint_combo_actual_idx(GapGveFFMpegGlobalParams *gpp, GtkWidget *widget, gint *gtab_ptr, gint val, gint maxidx)
{
  gint l_idx;

  for(l_idx = 0; l_idx < maxidx; l_idx++)
  {
    if(val == gtab_ptr[l_idx])
    {
      gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (widget), l_idx);
      return (l_idx);
    }
  }
  
  return(0);
}  /* end p_init_gint_combo_actual_idx */

/* ------------------------------------
 * p_init_gdouble_combo_actual_idx
 * ------------------------------------
 */
static gint
p_init_gdouble_combo_actual_idx(GapGveFFMpegGlobalParams *gpp, GtkWidget *widget, gdouble *gtab_ptr, gdouble val, gint maxidx)
{
  gint l_idx;

  for(l_idx = 0; l_idx < maxidx; l_idx++)
  {
    if(val == gtab_ptr[l_idx])
    {
      gimp_int_combo_box_set_active (GIMP_INT_COMBO_BOX (widget), l_idx);
      return (l_idx);
    }
  }
  return(0);
}  /* end p_init_gdouble_combo_actual_idx */

/* --------------------------------
 * p_init_combo_vals
 * --------------------------------
 */
static void
p_init_combo_vals(GapGveFFMpegGlobalParams *gpp)
{
  char *name;

  p_init_gint_combo_actual_idx(gpp, gpp->ff_motion_estimation_combo
                              , &gtab_motion_est[0]
                              , gpp->evl.motion_estimation
                              , GAP_GVE_FFMPEG_MOTION_ESTIMATION_MAX_ELEMENTS
                              );
  p_init_gint_combo_actual_idx(gpp, gpp->ff_dct_algo_combo
                              , &gtab_dct_algo[0]
                              , gpp->evl.dct_algo
                              , GAP_GVE_FFMPEG_DCT_ALGO_MAX_ELEMENTS
                              );
  p_init_gint_combo_actual_idx(gpp, gpp->ff_idct_algo_combo
                              , &gtab_idct_algo[0]
                              , gpp->evl.idct_algo
                              , GAP_GVE_FFMPEG_IDCT_ALGO_MAX_ELEMENTS
                              );
  p_init_gint_combo_actual_idx(gpp, gpp->ff_mb_decision_combo
                              , &gtab_mb_decision[0]
                              , gpp->evl.mb_decision
                              , GAP_GVE_FFMPEG_MB_DECISION_MAX_ELEMENTS
                              );

  p_init_gint_combo_actual_idx(gpp, gpp->ff_aud_bitrate_combo
                              , &gtab_audio_krate[0]
                              , gpp->evl.audio_bitrate
                              , GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_MAX_ELEMENTS
                              );


  p_init_gdouble_combo_actual_idx(gpp, gpp->ff_aspect_combo
                              , &gtab_aspect[0]
                              , gpp->evl.factor_aspect_ratio
                              , GAP_GVE_FFMPEG_ASPECT_MAX_ELEMENTS
                              );

  name = p_init_combo_actual_nameidx(gpp, gpp->ff_fileformat_combo, glist_fileformat, gpp->evl.format_name);
  name = p_init_combo_actual_nameidx(gpp, gpp->ff_vid_codec_combo,  glist_vid_codec,  gpp->evl.vcodec_name);
  name = p_init_combo_actual_nameidx(gpp, gpp->ff_aud_codec_combo,  glist_aud_codec,  gpp->evl.acodec_name);

}  /* end p_init_combo_vals */


/* --------------------------------
 * p_set_combo_box_callbacks
 * --------------------------------
 */
static void
p_set_combo_box_callbacks(GapGveFFMpegGlobalParams *gpp)
{
  /* dynamic combos
   * the entries for available fileformats and codecs
   * are set up by queries to the FFMPEG avcodec library
   */

  av_register_all();  /* register all fileformats and codecs before we can use the lib */

  p_replace_combo_file_format(gpp);
  p_replace_combo_vid_codec(gpp);
  p_replace_combo_aud_codec(gpp);

}  /* end p_set_combo_box_callbacks */



/* --------------------------------
 * p_init_spinbuttons
 * --------------------------------
 */
static void
p_init_spinbuttons(GapGveFFMpegGlobalParams *gpp)
{
  GtkAdjustment *adj;

  if(gap_debug) printf("p_init_spinbuttons\n");

  adj = GTK_ADJUSTMENT(gpp->ff_aud_bitrate_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.audio_bitrate);

  adj = GTK_ADJUSTMENT(gpp->ff_vid_bitrate_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.video_bitrate);

  adj = GTK_ADJUSTMENT(gpp->ff_qscale_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qscale);

  adj = GTK_ADJUSTMENT(gpp->ff_qmin_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qmin);

  adj = GTK_ADJUSTMENT(gpp->ff_qmax_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qmax);

  adj = GTK_ADJUSTMENT(gpp->ff_qdiff_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qdiff);


  adj = GTK_ADJUSTMENT(gpp->ff_gop_size_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.gop_size);



  adj = GTK_ADJUSTMENT(gpp->ff_qblur_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qblur);

  adj = GTK_ADJUSTMENT(gpp->ff_qcomp_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.qcomp);

  adj = GTK_ADJUSTMENT(gpp->ff_rc_init_cplx_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.rc_init_cplx);

  adj = GTK_ADJUSTMENT(gpp->ff_b_qfactor_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.b_qfactor);

  adj = GTK_ADJUSTMENT(gpp->ff_i_qfactor_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.i_qfactor);

  adj = GTK_ADJUSTMENT(gpp->ff_b_qoffset_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.b_qoffset);

  adj = GTK_ADJUSTMENT(gpp->ff_i_qoffset_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.i_qoffset);

  adj = GTK_ADJUSTMENT(gpp->ff_bitrate_tol_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.bitrate_tol);

  adj = GTK_ADJUSTMENT(gpp->ff_maxrate_tol_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.maxrate_tol);

  adj = GTK_ADJUSTMENT(gpp->ff_minrate_tol_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.minrate_tol);

  adj = GTK_ADJUSTMENT(gpp->ff_bufsize_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.bufsize);

  adj = GTK_ADJUSTMENT(gpp->ff_strict_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.strict);

  adj = GTK_ADJUSTMENT(gpp->ff_mb_qmin_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.mb_qmin);

  adj = GTK_ADJUSTMENT(gpp->ff_mb_qmax_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.mb_qmax);

  adj = GTK_ADJUSTMENT(gpp->ff_b_frames_spinbutton_adj);
  gtk_adjustment_set_value(adj, (gfloat)gpp->evl.b_frames);

}  /* end p_init_spinbuttons */


/* --------------------------------
 * p_init_vid_checkbuttons
 * --------------------------------
 */
static void
p_init_vid_checkbuttons(GapGveFFMpegGlobalParams *gpp)
{
  gint32 flag;

  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_intra_checkbutton)
                               , gpp->evl.intra);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_bitexact_checkbutton)
                               , gpp->evl.bitexact);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_aspect_checkbutton)
                               , gpp->evl.set_aspect_ratio);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_aic_checkbutton)
                               , gpp->evl.aic);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_umv_checkbutton)
                               , gpp->evl.umv);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_mv4_checkbutton)
                               , gpp->evl.mv4);
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_partitioning_checkbutton)
                               , gpp->evl.partitioning);

  flag = (gpp->evl.pass == 2) ? TRUE : FALSE;
  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_pass_checkbutton), flag);

  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (gpp->ff_dont_recode_checkbutton)
                               , gpp->evl.dont_recode_flag);
}   /* end p_init_vid_checkbuttons */

/* --------------------------------
 * p_init_entry_widgets
 * --------------------------------
 */
static void
p_init_entry_widgets(GapGveFFMpegGlobalParams *gpp)
{
  if(gap_debug) printf("p_init_entry_widgets\n");

  gtk_entry_set_text(GTK_ENTRY(gpp->ff_passlogfile_entry), gpp->evl.passlogfile);
  gtk_entry_set_text(GTK_ENTRY(gpp->ff_title_entry), gpp->evl.title);
  gtk_entry_set_text(GTK_ENTRY(gpp->ff_author_entry), gpp->evl.author);
  gtk_entry_set_text(GTK_ENTRY(gpp->ff_copyright_entry), gpp->evl.copyright);
  gtk_entry_set_text(GTK_ENTRY(gpp->ff_comment_entry), gpp->evl.comment);

}  /* end p_init_entry_widgets */

/* --------------------------------
 * gap_enc_ffgui_init_main_dialog_widgets
 * --------------------------------
 */
void
gap_enc_ffgui_init_main_dialog_widgets(GapGveFFMpegGlobalParams *gpp)
{
  if(gap_debug) printf("gap_enc_ffgui_init_main_dialog_widgets: Start INIT\n");

  /* put initial values to the widgets */

  p_init_spinbuttons(gpp);
  p_init_entry_widgets(gpp);
  p_init_vid_checkbuttons(gpp);
  p_init_combo_vals(gpp);

  gap_enc_ffgui_set_default_codecs(gpp, FALSE);               /* update info labels but DONT set CODEC combos */
}  /* end gap_enc_ffgui_init_main_dialog_widgets */


/* --------------------------------
 * gap_enc_ffgui_gettab_motion_est
 * --------------------------------
 */
gint
gap_enc_ffgui_gettab_motion_est(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_MOTION_ESTIMATION_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return(gtab_motion_est[idx]);

}  /* end gap_enc_ffgui_gettab_motion_est */

/* --------------------------------
 * gap_enc_ffgui_gettab_dct_algo
 * --------------------------------
 */
gint
gap_enc_ffgui_gettab_dct_algo(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_DCT_ALGO_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return (gtab_dct_algo[idx]);

}  /* end gap_enc_ffgui_gettab_dct_algo */

/* --------------------------------
 * gap_enc_ffgui_gettab_idct_algo
 * --------------------------------
 */
gint
gap_enc_ffgui_gettab_idct_algo(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_IDCT_ALGO_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return(gtab_idct_algo[idx]);

}  /* end gap_enc_ffgui_gettab_idct_algo */

/* --------------------------------
 * gap_enc_ffgui_gettab_mb_decision
 * --------------------------------
 */
gint
gap_enc_ffgui_gettab_mb_decision(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_MB_DECISION_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return(gtab_mb_decision[idx]);

}  /* end gap_enc_ffgui_gettab_mb_decision */

/* --------------------------------
 * gap_enc_ffgui_gettab_audio_krate
 * --------------------------------
 */
gint
gap_enc_ffgui_gettab_audio_krate(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return(gtab_audio_krate[idx]);

}  /* end gap_enc_ffgui_gettab_audio_krate */




/* --------------------------------
 * gap_enc_ffgui_gettab_aspect
 * --------------------------------
 */
gdouble
gap_enc_ffgui_gettab_aspect(gint idx)
{
 if((idx >= GAP_GVE_FFMPEG_ASPECT_MAX_ELEMENTS) || (idx < 1))
 {
    idx = 0;
 }

 return(gtab_aspect[idx]);

}  /* end gap_enc_ffgui_gettab_aspect */




/* --------------------------------
 * gap_enc_ffgui_create_fsb__fileselection
 * --------------------------------
 */
GtkWidget*
gap_enc_ffgui_create_fsb__fileselection (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *fsb__fileselection;
  GtkWidget *fsb__ok_button;
  GtkWidget *fsb__cancel_button;

  fsb__fileselection = gtk_file_selection_new (_("Select File"));
  gtk_container_set_border_width (GTK_CONTAINER (fsb__fileselection), 10);

  fsb__ok_button = GTK_FILE_SELECTION (fsb__fileselection)->ok_button;
  gtk_widget_show (fsb__ok_button);
  GTK_WIDGET_SET_FLAGS (fsb__ok_button, GTK_CAN_DEFAULT);

  fsb__cancel_button = GTK_FILE_SELECTION (fsb__fileselection)->cancel_button;
  gtk_widget_show (fsb__cancel_button);
  GTK_WIDGET_SET_FLAGS (fsb__cancel_button, GTK_CAN_DEFAULT);

  g_signal_connect (G_OBJECT (fsb__fileselection), "destroy",
                      G_CALLBACK (on_fsb__fileselection_destroy),
                      gpp);
  g_signal_connect (G_OBJECT (fsb__ok_button), "clicked",
                      G_CALLBACK (on_fsb__ok_button_clicked),
                      gpp);
  g_signal_connect (G_OBJECT (fsb__cancel_button), "clicked",
                      G_CALLBACK (on_fsb__cancel_button_clicked),
                      gpp);

  return fsb__fileselection;
}  /* end gap_enc_ffgui_create_fsb__fileselection */



/* --------------------------------
 * p_create_basic_options_frame
 * --------------------------------
 */
GtkWidget*
p_create_basic_options_frame (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *frame;
  GtkWidget *table;
  GtkWidget *label;
  GtkWidget *combo;
  GtkObject *adj;
  GtkWidget *spinbutton;
  
  gint       row;
  gint       inital_value;
  


  frame = gimp_frame_new (_("FFMpeg Basic Encoder Options"));

  table = gtk_table_new (11, 3, FALSE);
  gtk_widget_show (table);
  gtk_container_add (GTK_CONTAINER (frame), table);
  gtk_container_set_border_width (GTK_CONTAINER (table), 2);
  gtk_table_set_row_spacings (GTK_TABLE (table), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table), 4);


  row = 0;
  
  /* the fileformat label */
  label = gtk_label_new (_("Fileformat:           "));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  /* the fileformat combo box */
  combo =  gimp_int_combo_box_new (NULL, 0);
  gpp->ff_fileformat_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo
                           , _("The output multimedia fileformat")
			   , NULL);

  /* ff_fileformat_combo_menu and callback are replaced later 
   * in procedure p_replace_combo_file_format 
   */


  row++;

  /* the video codec label */
  label = gtk_label_new (_("Video CODEC:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the video codec  combo box */
  combo =  gimp_int_combo_box_new (NULL, 0);
  gpp->ff_vid_codec_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("The video codec"), NULL);

  /* ff_vid_codec_combo is replaced later 
   * in procedure p_replace_combo_vid_codec
   */

  row++;

  /* the audio codec label */
  label = gtk_label_new (_("Audio CODEC:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the audio codec  combo box */
  combo =  gimp_int_combo_box_new (NULL, 0);
  gpp->ff_aud_codec_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("The audio codec"), NULL);
  
  /* ff_aud_codec_combo is replaced later 
   * in procedure p_replace_combo_aud_codec
   */

  row++;

  /* the audio bitrate label */
  label = gtk_label_new (_("Audio Bitrate:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the audio bitrate spinbutton */
  adj = gtk_adjustment_new (160, 0, 500, 10, 100, 100);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_aud_bitrate_spinbutton_adj = adj;
  gpp->ff_aud_bitrate_spinbutton     = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("Audio bitrate in kBit/sec"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.audio_bitrate);
 
  /* the audio bitrate combo */
  combo = gimp_int_combo_box_new ("32",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_00_32,
                                  "40",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_01_40,
				  "48",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_02_48,
				  "56",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_03_56,
				  "64",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_04_64,
				  "80",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_05_80,
				  "96",   GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_06_96,
				  "112",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_07_112,
				  "128",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_08_128,
				  "160",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_09_160,
				  "192",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_10_192,
				  "224",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_11_224,
				  "256",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_12_256,
				  "320",  GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_13_320,
                                  NULL);

  gpp->ff_aud_bitrate_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table), combo, 2, 3, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Common used audio bitrates"), NULL);
  inital_value = p_init_gint_combo_actual_idx(gpp
                              , combo
                              , &gtab_audio_krate[0]
                              , gpp->evl.audio_bitrate
                              , GAP_GVE_FFMPEG_AUDIO_KBIT_RATE_MAX_ELEMENTS
                              );
  
  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_aud_bitrate_combo),
                              gpp);


  row++;

  /* the video bitrate label */
  label = gtk_label_new (_("Video Bitrate:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the video bitrate spinbutton */
  adj = gtk_adjustment_new (1000, 0, 10000, 100, 1000, 1000);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_vid_bitrate_spinbutton_adj = adj;
  gpp->ff_vid_bitrate_spinbutton     = spinbutton;

  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("Video bitrate kBit/sec"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.video_bitrate);


  row++;


  /* the qscale label */
  label = gtk_label_new (_("qscale:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

 
  /* the qscale spinbutton */
  adj = gtk_adjustment_new (0, 0, 31, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_qscale_spinbutton_adj = adj;
  gpp->ff_qscale_spinbutton     = spinbutton;

  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("Use fixed video quantiser scale (VBR) (0=const bitrate)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.qscale);

  row++;

 
  /* the qmin label */
  label = gtk_label_new (_("qmin:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);



  /* the qmin spinbutton */
  adj = gtk_adjustment_new (1, 0, 31, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_qmin_spinbutton_adj = adj;
  gpp->ff_qmin_spinbutton     = spinbutton;

  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("min video quantiser scale (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.qmin);

  row++;


  /* the qmax label */
  label = gtk_label_new (_("qmax:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);
 
  /* the qmax spinbutton */
  adj = gtk_adjustment_new (1, 0, 31, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_qmax_spinbutton_adj = adj;
  gpp->ff_qmax_spinbutton     = spinbutton;

  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("max video quantiser scale (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.qmax);


  row++;


  /* the qdiff label */
  label = gtk_label_new (_("qdiff:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  /* the qdiff spinbutton */
  adj = gtk_adjustment_new (3, 0, 100, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_qdiff_spinbutton_adj = adj;
  gpp->ff_qdiff_spinbutton     = spinbutton;

  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("max difference between the quantiser scale (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.qdiff);


  return(frame); 
}  /* end  p_create_basic_options_frame */



/* --------------------------------
 * p_create_expert_algortihms_frame
 * --------------------------------
 */
GtkWidget*
p_create_expert_algortihms_frame (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *frame;
  GtkWidget *flags_frame;
  GtkWidget *table2;
  GtkWidget *label;
  GtkWidget *combo;
  GtkObject *adj;
  GtkWidget *spinbutton;
  GtkWidget *checkbutton;
  
  gint       row;
  gint       inital_value;
  
  frame = gimp_frame_new (_("FFMpeg Expert Encoder Algorithms and Flags"));

  table2 = gtk_table_new (7, 3, FALSE);
  gtk_widget_show (table2);
  gtk_container_add (GTK_CONTAINER (frame), table2);
  gtk_container_set_border_width (GTK_CONTAINER (table2), 2);
  gtk_table_set_row_spacings (GTK_TABLE (table2), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table2), 4);

  row = 0;
  
  /* the motion estimation label */
  label = gtk_label_new (_("Motion Estimation:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  /* the motion estimation combo box */
  combo = gimp_int_combo_box_new (_("1 zero (fastest)"),     GAP_GVE_FFMPEG_MOTION_ESTIMATION_00_ZERO,
                                  _("2 full (best)"),        GAP_GVE_FFMPEG_MOTION_ESTIMATION_01_FULL,
                                  _("3 log"),                GAP_GVE_FFMPEG_MOTION_ESTIMATION_02_LOG,
                                  _("4 phods"),              GAP_GVE_FFMPEG_MOTION_ESTIMATION_03_PHODS,
                                  _("5 epzs (recommanded)"), GAP_GVE_FFMPEG_MOTION_ESTIMATION_04_EPZS,
                                  _("6 x1"),                 GAP_GVE_FFMPEG_MOTION_ESTIMATION_05_X1,
                                  NULL);
  gpp->ff_motion_estimation_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table2), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Select algorithm for motion estimation"), NULL);

  inital_value =  p_init_gint_combo_actual_idx(gpp
                              , combo
                              , &gtab_motion_est[0]
                              , gpp->evl.motion_estimation
                              , GAP_GVE_FFMPEG_MOTION_ESTIMATION_MAX_ELEMENTS
                              );
  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_motion_estimation_combo),
                              gpp);


  row++;
  
  
  /* the DCT algorithm label */
  label = gtk_label_new (_("DCT algorithm:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the DCT algorithm combo */
  combo = gimp_int_combo_box_new (_("0 auto"),         GAP_GVE_FFMPEG_DCT_ALGO_00_AUTO,
                                  _("1 fast int"),     GAP_GVE_FFMPEG_DCT_ALGO_01_FASTINT,
                                  _("2 int"),          GAP_GVE_FFMPEG_DCT_ALGO_02_INT,
                                  _("3 mmx"),          GAP_GVE_FFMPEG_DCT_ALGO_03_MMX,
                                  _("4 mlib"),         GAP_GVE_FFMPEG_DCT_ALGO_04_MLIB,
                                  _("5 altivec"),      GAP_GVE_FFMPEG_DCT_ALGO_05_ALTIVEC,
                                  NULL);
  gpp->ff_dct_algo_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table2), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Select algorithm for DCT"), NULL);

  inital_value =  p_init_gint_combo_actual_idx(gpp
                              , combo
                              , &gtab_dct_algo[0]
                              , gpp->evl.dct_algo
                              , GAP_GVE_FFMPEG_DCT_ALGO_MAX_ELEMENTS
                              );
  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_dct_algo_combo),
                              gpp);

  row++;
  

  /* the IDCT algorithm label */
  label = gtk_label_new (_("IDCT algorithm:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  /* the IDCT algorithm combo */
  combo = gimp_int_combo_box_new (_("0 auto"),         GAP_GVE_FFMPEG_IDCT_ALGO_00_AUTO,
                                  _("1 int"),          GAP_GVE_FFMPEG_IDCT_ALGO_01_INT,
                                  _("2 simple"),       GAP_GVE_FFMPEG_IDCT_ALGO_02_SIMPLE,
                                  _("3 simple mmx"),   GAP_GVE_FFMPEG_IDCT_ALGO_03_SIMPLEMMX,
                                  _("4 libmpeg2mmx"),  GAP_GVE_FFMPEG_IDCT_ALGO_04_LIBMPEG2MMX,
                                  _("5 ps2"),          GAP_GVE_FFMPEG_IDCT_ALGO_05_PS2,
                                  _("6 mlib"),         GAP_GVE_FFMPEG_IDCT_ALGO_06_MLIB,
                                  _("7 arm"),          GAP_GVE_FFMPEG_IDCT_ALGO_07_ARM,
                                  _("8 altivec"),      GAP_GVE_FFMPEG_IDCT_ALGO_08_ALTIVEC,
                                  NULL);

  gpp->ff_idct_algo_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table2), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Select algorithm for IDCT"), NULL);

  inital_value = p_init_gint_combo_actual_idx(gpp
                              , combo
                              , &gtab_idct_algo[0]
                              , gpp->evl.idct_algo
                              , GAP_GVE_FFMPEG_IDCT_ALGO_MAX_ELEMENTS
                              );

  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_idct_algo_combo),
                              gpp);


  row++;

  /* the MB_DECISION label */
  label = gtk_label_new (_("MB Decision:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the MB_DECISION combo */
  combo = gimp_int_combo_box_new (_("simple (use mb_cmp)"),                      GAP_GVE_FFMPEG_MB_DECISION_00_SIMPLE,
                                  _("bits (the one which needs fewest bits)"),   GAP_GVE_FFMPEG_MB_DECISION_01_BITS,
                                  _("rate distortion"),                         GAP_GVE_FFMPEG_MB_DECISION_02_RD,
                                  NULL);

  gpp->ff_mb_decision_combo = combo;
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table2), combo, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Select algorithm for macroblock decision"), NULL);

  inital_value = 

  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_mb_decision_combo),
                              gpp);

  row++;

  /* the GOP label */
  label = gtk_label_new (_("GOP:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);



  /* the GOP spinbutton */
  adj = gtk_adjustment_new (12, 0, 100, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_gop_size_spinbutton_adj = adj;
  gpp->ff_gop_size_spinbutton     = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table2), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("Group of picture size"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                    G_CALLBACK (on_ff_gint32_spinbutton_changed),
                    &gpp->evl.gop_size);

  row++;

  /* the B_frames label */
  label = gtk_label_new (_("B-Frames:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the B_frames spinbutton */
  adj = gtk_adjustment_new (0, 0, (gdouble)FF_MAX_B_FRAMES, 1, 1, 1);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_b_frames_spinbutton_adj = adj;
  gpp->ff_b_frames_spinbutton     = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table2), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("Max number of B-frames in sequence"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                    G_CALLBACK (on_ff_gint32_spinbutton_changed),
                    &gpp->evl.b_frames);

  row++;

  /* Flags label */
  label = gtk_label_new (_("Flags:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table2), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the (invisible) frame Flags container for the flag checkbuttons */
  flags_frame = gimp_frame_new (NULL);
  gtk_widget_show (flags_frame);
  gtk_table_attach (GTK_TABLE (table2), flags_frame, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);

  /* the flags table */
  {
    int flags_row;
    GtkWidget *flags_table;

    flags_table = gtk_table_new (8, 2, FALSE);
    gtk_widget_show (flags_table);
    gtk_container_add (GTK_CONTAINER (flags_frame), flags_table);
    gtk_container_set_border_width (GTK_CONTAINER (flags_table), 2);
    gtk_table_set_row_spacings (GTK_TABLE (flags_table), 4);
    gtk_table_set_col_spacings (GTK_TABLE (flags_table), 4);

    flags_row = 0;

    checkbutton = gtk_check_button_new_with_label (_("Intra Only"));
    gpp->ff_intra_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("use only intra frames (I)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.intra);

    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("Advanced intra coding"));
    gpp->ff_aic_checkbutton                 = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("activate intra frame coding (only h263+ CODEC)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.aic);


    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("Unlimited motion vector"));
    gpp->ff_umv_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("enable unlimited motion vector (only h263+ CODEC)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.umv);


    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("4 Motion Vectors"));
    gpp->ff_mv4_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("use four motion vector by macroblock (only MPEG-4 CODEC)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.mv4);
 

    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("Partitioning"));
    gpp->ff_partitioning_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("use data partitioning (only MPEG-4 CODEC)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.partitioning);


    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("Bitexact"));
    gpp->ff_bitexact_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("only use bit exact algorithms (for codec testing)"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.bitexact);


    flags_row++;

    checkbutton = gtk_check_button_new_with_label (_("Set Aspectratio"));
    gpp->ff_aspect_checkbutton = checkbutton;
    gtk_widget_show (checkbutton);
    gtk_table_attach (GTK_TABLE (flags_table), checkbutton, 0, 1, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (checkbutton, _("store aspectratio information (width/height) in the output video"), NULL);
    g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
    g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.set_aspect_ratio);

    /* the ASPECT combo */
    combo = gimp_int_combo_box_new (_("auto from pixelsize"),  GAP_GVE_FFMPEG_ASPECT_00_AUTO,
                                    _("3:2"),                  GAP_GVE_FFMPEG_ASPECT_01_3_2,
                                    _("4:3"),                  GAP_GVE_FFMPEG_ASPECT_02_4_3,
                                    _("16:9"),                 GAP_GVE_FFMPEG_ASPECT_03_16_9,
                                    NULL);

    gpp->ff_aspect_combo = combo;
    gtk_widget_show (combo);

    gtk_table_attach (GTK_TABLE (flags_table), combo, 1, 2, flags_row, flags_row+1,
                      (GtkAttachOptions) (GTK_FILL),
                      (GtkAttachOptions) (0), 0, 0);
    gimp_help_set_help_data (combo, _("Select aspect ratio"), NULL);

    inital_value =  p_init_gdouble_combo_actual_idx(gpp
                              , combo
                              , &gtab_aspect[0]
                              , gpp->evl.factor_aspect_ratio
                              , GAP_GVE_FFMPEG_ASPECT_MAX_ELEMENTS
                              );

    gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              inital_value,
                              G_CALLBACK (on_ff_aspect_combo),
                              gpp);
 
  }  /* end flags_table */


  row++;

  /* the dont_recode checkbutton */
  checkbutton = gtk_check_button_new_with_label (_("Dont Recode"));
  gpp->ff_dont_recode_checkbutton = checkbutton;
  gtk_widget_show (checkbutton);
  gtk_table_attach (GTK_TABLE (table2), checkbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (checkbutton
                        , _("Bypass the FFMPEG Vidoencoder where inputframes can "
			    "be copied 1:1 from an input MPEG videofile."
			    "This experimental feature provides lossless MPEG "
			    "video cut, but works only for the MPEG Fileformats.")
			, NULL);
  g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (checkbutton), "toggled",
                    G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                    &gpp->evl.dont_recode_flag);


  return(frame); 
}  /* end  p_create_expert_algortihms_frame */


/* --------------------------------
 * p_create_expert_options_frame
 * --------------------------------
 */
GtkWidget*
p_create_expert_options_frame (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *frame;
  GtkWidget *table4;
  GtkWidget *label;
  GtkObject *adj;
  GtkWidget *spinbutton;
  
  gint       row;

  frame = gimp_frame_new (_("FFMpeg Expert Encoder Options"));


  table4 = gtk_table_new (14, 3, FALSE);
  gtk_widget_show (table4);
  gtk_container_add (GTK_CONTAINER (frame), table4);
  gtk_container_set_border_width (GTK_CONTAINER (table4), 4);
  gtk_table_set_row_spacings (GTK_TABLE (table4), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table4), 4);

  row = 0;

  /* the qblur label */
  label = gtk_label_new (_("qblur:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the qblur spinbutton */
  adj = gtk_adjustment_new (0.5, 0, 100, 0.25, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_qblur_spinbutton_adj            = adj;
  gpp->ff_qblur_spinbutton                = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("video quantiser scale blur (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.qblur);
 
  
  
  row++;
  

  /* the qcomp label */
  label = gtk_label_new (_("qcomp:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the qcomp spinbutton */
  adj = gtk_adjustment_new (0.5, 0, 100, 0.25, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_qcomp_spinbutton_adj            = adj;
  gpp->ff_qcomp_spinbutton                = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("video quantiser scale compression (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.qcomp);
  
  row++;

  /* the rc-init-cplx label */
  label = gtk_label_new (_("rc-init-cplx:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the rc-init-cplx spinbutton */
  adj = gtk_adjustment_new (1.25, 0, 100, 0.25, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_rc_init_cplx_spinbutton_adj     = adj;
  gpp->ff_rc_init_cplx_spinbutton         = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, 2, 3,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("initial complexity for 1-pass encoding"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.rc_init_cplx);
  
  row++;

  /* the b-qfactor label */

  label = gtk_label_new (_("b-qfactor:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the b-qfactor spinbutton */
  adj = gtk_adjustment_new (1.25, -100, 100, 0.2, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_b_qfactor_spinbutton_adj        = adj;
  gpp->ff_b_qfactor_spinbutton            = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("qp factor between p and b frames"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.b_qfactor);
 
  row++;

  /* the i-qfactor label */
  label = gtk_label_new (_("i-qfactor:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the i-qfactor spinbutton */
  adj = gtk_adjustment_new (-0.8, -100, 100, 0.2, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_i_qfactor_spinbutton_adj        = adj;
  gpp->ff_i_qfactor_spinbutton            = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("qp factor between p and i frames"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.i_qfactor);

 
  row++;

  /* the b-qoffset label */
  label = gtk_label_new (_("b-qoffset:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  /* the b-qoffset spinbutton */
  adj = gtk_adjustment_new (1.25, 0, 100, 0.25, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_b_qoffset_spinbutton_adj        = adj;
  gpp->ff_b_qoffset_spinbutton            = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("qp offset between p and b frames"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.b_qoffset);
 
  row++;

  /* the i-qoffset label */
  label = gtk_label_new (_("i-qoffset:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the i-qoffset spinbutton */
  adj = gtk_adjustment_new (0, 0, 100, 0.25, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 2);
  gpp->ff_i_qoffset_spinbutton_adj        = adj;
  gpp->ff_i_qoffset_spinbutton            = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("qp offset between p and i frames"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gdouble_spinbutton_changed),
                      &gpp->evl.i_qoffset);

 
  row++;

  /* the Bitrate Tolerance label */
  label = gtk_label_new (_("Bitrate Tol:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Bitrate Tolerance spinbutton */
  adj = gtk_adjustment_new (4200, 0, 10000, 100, 1000, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_bitrate_tol_spinbutton_adj      = adj;
  gpp->ff_bitrate_tol_spinbutton          = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("set video bitrate tolerance (in kbit/s)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.bitrate_tol);
 
  row++;

  /* the Maxrate Tolerance label */
  label = gtk_label_new (_("Maxrate Tol:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

 
  /* the Maxrate Tolerance spinbutton */
  adj = gtk_adjustment_new (0, 0, 10000, 100, 1000, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_maxrate_tol_spinbutton_adj      = adj;
  gpp->ff_maxrate_tol_spinbutton          = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("set max video bitrate tolerance (in kbit/s)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.maxrate_tol);
 
 
  row++;


  /* the Minrate Tolerance label */
  label = gtk_label_new (_("Minrate Tol:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Minrate Tolerance spinbutton */
  adj = gtk_adjustment_new (0, 0, 10000, 100, 1000, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_minrate_tol_spinbutton_adj      = adj;
  gpp->ff_minrate_tol_spinbutton          = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("set min video bitrate tolerance (in kbit/s)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.minrate_tol);
 
  row++;


  /* the Bufsize label */
  label = gtk_label_new (_("Bufsize:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Bufsize spinbutton */
  adj = gtk_adjustment_new (0, 0, 10000, 100, 1000, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_bufsize_spinbutton_adj          = adj;
  gpp->ff_bufsize_spinbutton              = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("set ratecontrol buffere size (in kbit)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.bufsize);
 
  row++;


  /* the strictness label */
  label = gtk_label_new (_("strictness:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the strictness spinbutton */
  adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_strict_spinbutton_adj           = adj;
  gpp->ff_strict_spinbutton               = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("how strictly to follow the standards"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.strict);
 

  row++;


  /* the mb-qmin label */
  label = gtk_label_new (_("mb-qmin:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the mb-qmin spinbutton */
  adj = gtk_adjustment_new (0, 0, 31, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_mb_qmin_spinbutton_adj          = adj;
  gpp->ff_mb_qmin_spinbutton              = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("min macroblock quantiser scale (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.mb_qmin);

  row++;


  /* the mb-qmax label */
  label = gtk_label_new (_("mb-qmax:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table4), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the mb-qmax spinbutton */
  adj = gtk_adjustment_new (31, 0, 31, 1, 10, 10);
  spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 1, 0);
  gpp->ff_mb_qmax_spinbutton_adj          = adj;
  gpp->ff_mb_qmax_spinbutton              = spinbutton;
  gtk_widget_show (spinbutton);
  gtk_table_attach (GTK_TABLE (table4), spinbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (spinbutton, _("max macroblock quantiser scale (VBR)"), NULL);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_ADJ, (gpointer)adj);
  g_object_set_data (G_OBJECT (spinbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (spinbutton), "changed",
                      G_CALLBACK (on_ff_gint32_spinbutton_changed),
                      &gpp->evl.mb_qmax);
 
  return(frame); 
}  /* end  p_create_expert_options_frame */


/* --------------------------------
 * p_create_2pass_options_frame
 * --------------------------------
 */
GtkWidget*
p_create_2pass_options_frame (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *frame;
  GtkWidget *table5;
  GtkWidget *label;
  GtkWidget *entry;
  GtkWidget *button;
  GtkWidget *checkbutton;
  
  gint       row;

  frame = gimp_frame_new (_("FFMpeg 2 Pass Expert settings"));

  table5 = gtk_table_new (3, 3, FALSE);
  gtk_widget_show (table5);
  gtk_container_add (GTK_CONTAINER (frame), table5);
  gtk_container_set_border_width (GTK_CONTAINER (table5), 4);
  gtk_table_set_row_spacings (GTK_TABLE (table5), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table5), 4);

  row = 0;

  /* the pass_logfile checkbutton */
  checkbutton = gtk_check_button_new_with_label (_("2 Pass Encoding"));
  gpp->ff_pass_checkbutton                = checkbutton;
  gtk_widget_show (checkbutton);
  gtk_table_attach (GTK_TABLE (table5), checkbutton, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (checkbutton, _("Activate 2 pass encoding when set"), NULL);
  g_object_set_data (G_OBJECT (checkbutton), GAP_ENC_FFGUI_GPP, (gpointer)gpp);
  g_signal_connect (G_OBJECT (checkbutton), "toggled",
                      G_CALLBACK (on_ff_gint32_checkbutton_toggled),
                      &gpp->evl.pass);

  row++;
    
  /* the pass_logfile label */
  label = gtk_label_new (_("Pass Logfile:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table5), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);
  


  /* the pass_logfile entry */
  entry = gtk_entry_new ();
  gpp->ff_passlogfile_entry               = entry;
  gtk_widget_show (entry);
  gtk_table_attach (GTK_TABLE (table5), entry, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (entry, _("The pass logfile is only used as workfile for 2-pass encoding"), NULL);
  g_signal_connect (G_OBJECT (entry), "changed",
                      G_CALLBACK (on_ff_passlogfile_entry_changed),
                      gpp);

  /* the pass_logfile fileselector button */
  button = gtk_button_new_with_label (_("..."));
  gtk_widget_show (button);
  gtk_table_attach (GTK_TABLE (table5), button, 2, 3, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (button, _("Select pass logfile via file browser"), NULL);
  g_signal_connect (G_OBJECT (button), "clicked",
                      G_CALLBACK (on_ff_passlogfile_filesel_button_clicked),
                      gpp);

  return(frame); 
}  /* end  p_create_2pass_options_frame */


/* --------------------------------
 * p_create_file_comment_frame
 * --------------------------------
 */
GtkWidget*
p_create_file_comment_frame (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *frame;
  GtkWidget *table6;
  GtkWidget *label;
  GtkWidget *entry;
  
  gint       row;

  frame = gimp_frame_new (_("FFMpeg File Comment settings"));


  table6 = gtk_table_new (5, 2, FALSE);
  gtk_widget_show (table6);
  gtk_container_add (GTK_CONTAINER (frame), table6);
  gtk_container_set_border_width (GTK_CONTAINER (table6), 4);
  gtk_table_set_row_spacings (GTK_TABLE (table6), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table6), 4);

  row = 0;

  /* the title lable */  
  label = gtk_label_new (_("Title:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table6), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);
 
  /* the title entry */  
  entry = gtk_entry_new_with_max_length (40);
  gpp->ff_title_entry                     = entry;
  gtk_widget_show (entry);
  gtk_table_attach (GTK_TABLE (table6), entry, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  g_signal_connect (G_OBJECT (entry), "changed",
                      G_CALLBACK (on_ff_title_entry_changed),
                      gpp);


  row++;

  /* the Author lable */  
  label = gtk_label_new (_("Author:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table6), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Author entry */  
  entry = gtk_entry_new_with_max_length (40);
  gpp->ff_author_entry                    = entry;
  gtk_widget_show (entry);
  gtk_table_attach (GTK_TABLE (table6), entry, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  g_signal_connect (G_OBJECT (entry), "changed",
                      G_CALLBACK (on_ff_author_entry_changed),
                      gpp);

  row++;

  /* the Copyright lable */  
  label = gtk_label_new (_("Copyright:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table6), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Copyright entry */  
  entry = gtk_entry_new_with_max_length (40);
  gpp->ff_copyright_entry                 = entry;
  gtk_widget_show (entry);
  gtk_table_attach (GTK_TABLE (table6), entry, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  g_signal_connect (G_OBJECT (entry), "changed",
                      G_CALLBACK (on_ff_copyright_entry_changed),
                      gpp);


  row++;

  /* the Comment lable */  
  label = gtk_label_new (_("Comment:"));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table6), label, 0, 1, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);

  /* the Comment entry */  
  entry = gtk_entry_new_with_max_length (80);
  gpp->ff_comment_entry                   = entry;
  gtk_widget_show (entry);
  gtk_table_attach (GTK_TABLE (table6), entry, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  g_signal_connect (G_OBJECT (entry), "changed",
                      G_CALLBACK (on_ff_comment_entry_changed),
                      gpp);

  row++;

  /* the filecomment_label lable */  
  label = gtk_label_new (_("\nText tags will be inserted in the\n"
                           "resulting video for all non blank entry fields."));
  gtk_widget_show (label);
  gtk_table_attach (GTK_TABLE (table6), label, 1, 2, row, row+1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);


  return(frame); 
}  /* end  p_create_file_comment_frame */




/* --------------------------------
 * p_create_ffmpeg_dialog_shell
 * --------------------------------
 */
GtkWidget*
p_create_ffmpeg_dialog_shell (GapGveFFMpegGlobalParams *gpp)
{
  GtkWidget *shell_window;
  GtkWidget *dialog_vbox2;
  GtkWidget *notebook1;
  GtkWidget *frame_preset;
  GtkWidget *frame;

  GtkWidget *table_preset;

  GtkWidget *nb1_label1;
  GtkWidget *nb1_label2;
  GtkWidget *nb1_label3;
  GtkWidget *nb1_label4;
  GtkWidget *nb1_label5;



  GtkWidget *combo;
  GtkWidget *ff_basic_info_label;
  GtkWidget *spc_hbox;


  /* set the widgets to defined NULL before we create them
   * (some callbacks may refer to those widgets before
   *  all of them are created. those callbacks check for NULL
   *  but would crash if the widgets are undefined yet)
   */
  gpp->ff_aspect_combo = NULL;
  gpp->ff_aud_bitrate_combo = NULL;
  gpp->ff_aud_bitrate_spinbutton = NULL;
  gpp->ff_aud_codec_combo = NULL;
  gpp->ff_author_entry = NULL;
  gpp->ff_b_frames_spinbutton = NULL;
  gpp->ff_b_qfactor_spinbutton = NULL;
  gpp->ff_b_qoffset_spinbutton = NULL;
  gpp->ff_basic_info_label = NULL;
  gpp->ff_bitrate_tol_spinbutton = NULL;
  gpp->ff_bufsize_spinbutton = NULL;
  gpp->ff_comment_entry = NULL;
  gpp->ff_copyright_entry = NULL;
  gpp->ff_dct_algo_combo = NULL;
  gpp->ff_dont_recode_checkbutton = NULL;
  gpp->ff_fileformat_combo = NULL;
  gpp->ff_gop_size_spinbutton = NULL;
  gpp->ff_bitexact_checkbutton = NULL;
  gpp->ff_aspect_checkbutton = NULL;
  gpp->ff_aic_checkbutton = NULL;
  gpp->ff_umv_checkbutton = NULL;
  gpp->ff_i_qfactor_spinbutton = NULL;
  gpp->ff_i_qoffset_spinbutton = NULL;
  gpp->ff_idct_algo_combo = NULL;
  gpp->ff_intra_checkbutton = NULL;
  gpp->ff_maxrate_tol_spinbutton = NULL;
  gpp->ff_mb_qmax_spinbutton = NULL;
  gpp->ff_mb_qmin_spinbutton = NULL;
  gpp->ff_mb_decision_combo = NULL;
  gpp->ff_minrate_tol_spinbutton = NULL;
  gpp->ff_motion_estimation_combo = NULL;
  gpp->ff_mv4_checkbutton = NULL;
  gpp->ff_partitioning_checkbutton = NULL;
  gpp->ff_pass_checkbutton = NULL;
  gpp->ff_passlogfile_entry = NULL;
  gpp->ff_presets_combo = NULL;
  gpp->ff_qblur_spinbutton = NULL;
  gpp->ff_qcomp_spinbutton = NULL;
  gpp->ff_qdiff_spinbutton = NULL;
  gpp->ff_qmax_spinbutton = NULL;
  gpp->ff_qmin_spinbutton = NULL;
  gpp->ff_qscale_spinbutton = NULL;
  gpp->ff_rc_init_cplx_spinbutton = NULL;
  gpp->ff_strict_spinbutton = NULL;
  gpp->ff_title_entry = NULL;
  gpp->ff_vid_bitrate_spinbutton = NULL;
  gpp->ff_vid_codec_combo = NULL;


  shell_window = gimp_dialog_new (_("FFMPEG Video Encode Parameters"),
                         GAP_PLUGIN_NAME_FFMPEG_PARAMS,
                         NULL, 0,
                         gimp_standard_help_func, GAP_HELP_ID_FFMPEG_PARAMS,

                         GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                         GTK_STOCK_OK,     GTK_RESPONSE_OK,
                         NULL);

  g_signal_connect (G_OBJECT (shell_window), "response",
                    G_CALLBACK (on_ff_response),
                    gpp);


  dialog_vbox2 = GTK_DIALOG (shell_window)->vbox;
  gtk_widget_show (dialog_vbox2);


  /* ================== */
  /* the preset frame   */
  /* ================== */
  spc_hbox = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (spc_hbox);
  frame_preset = gimp_frame_new (_("Parameter Presets"));
  gtk_widget_show (frame_preset);

  gtk_box_pack_start (GTK_BOX (spc_hbox), frame_preset, TRUE, TRUE, 10);
  gtk_box_pack_start (GTK_BOX (dialog_vbox2), spc_hbox, TRUE, TRUE, 4);
 
  /* the preset table */
  table_preset = gtk_table_new (2, 1, FALSE);
  gtk_widget_show (table_preset);
  gtk_container_add (GTK_CONTAINER (frame_preset), table_preset);
  gtk_container_set_border_width (GTK_CONTAINER (table_preset), 2);
  gtk_table_set_row_spacings (GTK_TABLE (table_preset), 4);
  gtk_table_set_col_spacings (GTK_TABLE (table_preset), 4);


  /* the presets combo */
  combo = gimp_int_combo_box_new (
     _("** OOPS do not change any parameter **"),   GAP_GVE_FFMPEG_PRESET_00_NONE,
     _("use DivX VBR, default presets"),            GAP_GVE_FFMPEG_PRESET_01_DIVX_DEFAULT,
     _("use DivX VBR, best quality presets"),       GAP_GVE_FFMPEG_PRESET_02_DIVX_BEST,
     _("use DivX VBR, low quality presets"),        GAP_GVE_FFMPEG_PRESET_03_DIVX_LOW,
     _("use MPEG1 fixed rate (VCD) presets"),       GAP_GVE_FFMPEG_PRESET_04_MPEG1_VCD,
     _("use MPEG1 VBR, best quality presets"),      GAP_GVE_FFMPEG_PRESET_05_MPEG1_BEST,
     _("use MPEG2 VBR (DVD) presets"),              GAP_GVE_FFMPEG_PRESET_06_MPEG2_VBR,
     _("use REAL video presets"),                   GAP_GVE_FFMPEG_PRESET_07_REAL,
     NULL);
  gpp->ff_presets_combo                   = combo;

  gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),
                              0,                /* initial int value */
                              G_CALLBACK (on_ff_presets_combo),
                              gpp);

  /* todo: 
   * the on_ff_presets_combo callback should run when the same
   * item is selected again (to restore the presets for all the other widgets
   * that could have been changed since the same preset item was selected
   * the last time)
   * but the combo box widgets seems to support only the "changed" signal
   * 
   * therefore the on_ff_presets_combo callback does always swicth back
   * to index 0 (OOPS, dont change preset params)
   */
     
  gtk_widget_show (combo);
  gtk_table_attach (GTK_TABLE (table_preset), combo, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL | GTK_EXPAND),
                    (GtkAttachOptions) (0), 0, 0);
  gimp_help_set_help_data (combo, _("Predefined encoder parameter settings"), NULL);




  /* the info label */
  ff_basic_info_label = gtk_label_new ("this text is replaced by the current"
                                       " preset/parameter description at runtime");
  gpp->ff_basic_info_label                = ff_basic_info_label;
  gtk_widget_show (ff_basic_info_label);
  gtk_table_attach (GTK_TABLE (table_preset), ff_basic_info_label, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);

  gtk_label_set_justify (GTK_LABEL (ff_basic_info_label), GTK_JUSTIFY_LEFT);
  gtk_misc_set_alignment (GTK_MISC (ff_basic_info_label), 0, 0.5);


  /* ================== */
  /* the parmeter frame */
  /* ================== */
  spc_hbox = gtk_hbox_new (FALSE, 0);
  gtk_widget_show (spc_hbox);
  frame = gimp_frame_new (_("Parameter Values"));
  gtk_widget_show (frame);
  gtk_box_pack_start (GTK_BOX (spc_hbox), frame, TRUE, TRUE, 10);
  gtk_box_pack_start (GTK_BOX (dialog_vbox2), spc_hbox, TRUE, TRUE, 4);

  /* the notebook for detailed parameter settings */
  /* -------------------------------------------- */
  notebook1 = gtk_notebook_new ();
  gtk_widget_show (notebook1);
  gtk_container_add (GTK_CONTAINER (frame), notebook1);
  gtk_container_set_border_width (GTK_CONTAINER (notebook1), 4);

  /* the frame with basic options */
  frame = p_create_basic_options_frame(gpp);
  gtk_widget_show (frame);

  gtk_container_add (GTK_CONTAINER (notebook1), frame);
  gtk_container_set_border_width (GTK_CONTAINER (frame), 4);

  /* the notebook page label for basic options */
  nb1_label1 = gtk_label_new (_("Basic Options"));
  gtk_widget_show (nb1_label1);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), nb1_label1);


  /* the frame with expert_algortihms */
  frame = p_create_expert_algortihms_frame(gpp);
  gtk_widget_show (frame);
  
  gtk_container_add (GTK_CONTAINER (notebook1), frame);
  gtk_container_set_border_width (GTK_CONTAINER (frame), 4);

  /* the notebook page label for expert algorithms */
  nb1_label2 = gtk_label_new (_("Expert Algorithms"));
  gtk_widget_show (nb1_label2);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 1), nb1_label2);


  /* the frame with expert_options */
  frame = p_create_expert_options_frame(gpp);
  gtk_widget_show (frame);

  gtk_container_add (GTK_CONTAINER (notebook1), frame);
  gtk_container_set_border_width (GTK_CONTAINER (frame), 4);

  /* the notebook page label for expert encoder options */
  nb1_label3 = gtk_label_new (_("Expert Options"));
  gtk_widget_show (nb1_label3);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), nb1_label3);


  /* the frame with the 2-pass settings */
  frame = p_create_2pass_options_frame(gpp);
  gtk_widget_show (frame);

  gtk_container_add (GTK_CONTAINER (notebook1), frame);
  gtk_container_set_border_width (GTK_CONTAINER (frame), 4);

  /* the notebook page label for 2 Pass Expert settings */
  nb1_label4 = gtk_label_new (_("Expert 2Pass"));
  gtk_widget_show (nb1_label4);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 3), nb1_label4);


  /* the frame with the 2-pass settings */
  frame = p_create_file_comment_frame(gpp);
  gtk_widget_show (frame);

  gtk_container_add (GTK_CONTAINER (notebook1), frame);
  gtk_container_set_border_width (GTK_CONTAINER (frame), 4);


  /* the notebook page label for file comment settings */
  nb1_label5 = gtk_label_new (_("File Comment"));
  gtk_widget_show (nb1_label5);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), nb1_label5);

  return shell_window;
}  /* end p_create_ffmpeg_dialog_shell */

/* ----------------------------------
 * gap_enc_ffgui_ffmpeg_encode_dialog
 * ----------------------------------
 *   return  0 .. OK
 *          -1 .. in case of Error or cancel
 */
gint
gap_enc_ffgui_ffmpeg_encode_dialog(GapGveFFMpegGlobalParams *gpp)
{
  if(gap_debug) printf("gap_enc_ffgui_ffmpeg_encode_dialog: Start\n");

  gimp_ui_init ("gap_video_extract", FALSE);
  gap_stock_init();

  /* ---------- sub dialog windows ----------*/
  gpp->fsb__fileselection = NULL;   /* used for pass log fileselection */
  gpp->ecp = NULL;

  if(gap_debug) printf("gap_enc_ffgui_ffmpeg_encode_dialog: Before p_create_ffmpeg_dialog_shell\n");

  /* ---------- dialog ----------*/
  gpp->shell_window = p_create_ffmpeg_dialog_shell (gpp);

  if(gap_debug) printf("p_ffmpeg_encode_dialog: After p_create_ffmpeg_dialog_shell\n");

  p_set_combo_box_callbacks(gpp);
  gap_enc_ffgui_init_main_dialog_widgets(gpp);
  gtk_widget_show (gpp->shell_window);

  gpp->val.run = 0;
  gtk_main ();

  if(gap_debug) printf("p_ffmpeg_encode_dialog: A F T E R gtk_main run:%d\n", (int)gpp->val.run);

  if(gpp->val.run)
  {
    return 0;
  }
  return -1;
}    /* end gap_enc_ffgui_ffmpeg_encode_dialog (productive version) */
